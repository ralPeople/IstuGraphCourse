\documentclass[../../main.tex]{subfiles}



\begin{document}

\section{Алгоритм Деикстры}

\subsection{Описание алгоритма, доказательство корректности}

Алгоритм Деикстры используется в произвольном графе для нахождения кратчайшего расстояния от вершины $S$ до всех прочих вершин графа. 
\textbf{Важное условие работы алгоритма}: в графе должны отсутствовать циклы отрицательного веса. Алгоритм работает как для ориентированных, так и для не ориентированных графов.

Алгоритм Деикстры является оптимизацией алгоритма \textbf{bfs 0-k}. На самом деле я не знаю, какой алгоритм появился раньше, но так как мы изучили 
\textbf{bfs 0-k} раньше, то будем шагать от этого. Вспоминаем, как работает алгоритм \textbf{bfs 0-k}: создадим очереди вершин с расстоянием $x$ и будем
рассматривать их в порядке увеличения расстояния. Такой алгоритм работает за $O(k(n+m))$, ведь мы максимальный путь в графе равен $(n-1)k$. 

Однако, много расстояний мы просто не посещаем, ведь каждую вершину мы посетим один раз, и часто мы проходим по такой длине пути $x$, что вершин с такой длиной просто нет.
Всего вершин $n$, а расстояний $(n-1)k$, их намного больше. Алгоритм Деикстры говорит: давайте просто возьмем любую вершину с минимальным расстоянием и посмотрим все ребра из нее.
Это то же самое, что и \textbf{bfs 0-k}, но при этом мы не посещаем несуществующие расстояние, мы сразу берем вершину с минимальным расстоянием. 
По факту, в алгоритме \textbf{bfs} мы делаем то же самое, мы всегда берем вершину с минимальным расстоянием и смотрим все пути из нее, просто в алгоритме \textbf{bfs} следующее расстояние
всегда равно $x+1$, а здесь оно может быть любым, потому что ребро может иметь любой вес. 

\textbf{Доказательство}: предположим, что алгоритм Деикстры нашел расстояние для первых $k$ вершин правильно, тогда давайте докажем, что
для следующей вершины всегда находится оптимальное расстояние. Предположим, что алгоритм нашел не самое кратчайшее расстояние $W$, а расстояние $d_x$. 
Тогда существует какой-то путь до текущей вершины $x$ с расстоянием $W$. Рассмотрим последнюю помеченную вершину на этом пути, пусть это вершина $y$ (такая вершина всегда есть). 
Но $d_y < W$, тогда вершина $y$ не может быть последней помеченной вершиной, противоречие (иначе наш алгоритм сначала проверил все 
ребра из вершины $y$ и пометил вершину $z$, так как она лежит на оптимальном пути до $y$, то $d_z \leq d_y$). 

\subsection{Как закодить}

Рассмотрим, как написать алгоритм Деикстры, чтобы найти расстояние до всех вершин в графе от вершины $S$. 
Обратите внимание, здесь ребро задано не только парой вершин, но еще и весом, поэтому для хранения графа мы создадим структуру:

\subTitleStyle{Пример 1 (файл struct)}

\ExampleFull{Sections/Dijkstra/struct.cpp}

\subTitleStyle{Конец примера 1}

Давайте выпишем шаги алгоритма:
\begin{enumerate}[label=\Roman*]
    \item Выбрать нерасмотренную вершину с минимальным расстоянием
    \item Рассмотреть все ребра из найденной вершины 
\end{enumerate}
Понятно, что можно выбрать нерасмотренную вершину просто найдя минимум в массиве $d$ ($d$ --- массив расстояний). 
Но можно воспользоваться структурами данных, например, двоичной кучей для поиска минимума в массиве. Мы рассмотрим также реализацию через красно-черное дерево. 

Итак, приведем сам код через \textit{set}:

\subTitleStyle{Пример 2 (файл algo)}

\ExampleFull{Sections/Dijkstra/algo.cpp}

\subTitleStyle{Конец примера 2}

Как только мы нашли лучшее расстояние до вершины, мы удаляем ее из сета и добавляем новое, обновленное расстояние. Можно написать реализацию и по-другому, 
которая оказывается даже быстрее. Видите ли, удалять из сета не очень легко, хоть это и делается за $O( \log{n} )$. Можно использовать двоичную кучу, 
которая умеет доставать максимум за $O( \log{n} )$. Видите ли, нам нужно доставать минимум, но мы можем складывать значения со знаком минус. 

\subTitleStyle{Пример 3 (файл algo2)}

\ExampleFull{Sections/Dijkstra/algo2.cpp}

\subTitleStyle{Конец примера 3}

В среднем, решение через очередь работает быстрее.

\textbf{Обратите внимание}. Максимальное расстояние может достигнуть порядка $nw$, где обычно $n \approx 10^5, w \approx 10^{9}$, тогда $10^{14}$ не помещается в тип
\textit{int}, но помещается в тип \textit{long long}, поэтому будьте внимательнее. Сохраняйте ответ в подходящем типе данных.  

\subsection{Итоговая асимптотика}

Оба алгоритма достают для каждого из $m$ ребер вершину за $\log{n}$, итого асимптотика $O(m \log{n})$. 

\subsection{Восстановление ответа}

Восстановить ответ в Алгоритме Деикстры так же просто, как и в \textbf{bfs}. Заведем массив $p$, где $p_x$ --- из какой вершины мы попали в вершину $x$ по оптимальному пути, когда
мы обновляем ответ для вершины $x$ мы обновим значение $p_x$.

\subTitleStyle{Пример 4 (файл algo\_p)}

\ExampleFull{Sections/Dijkstra/algo_p.cpp}

\subTitleStyle{Конец примера 4}

\subsection{Еще один пример применения алгоритма}

Часто может встретиться похожая задача: есть расписание поездов, из города $x$ поезд уходит в момент времени $t_i$ и через $w_i$ секунд добирается до города $y_i$. 
Таким образом, у нас есть взвешенный ориентированный граф, где есть ребра вида $(\text{откуда}, \text{куда}, t_i, w_i)$. Мы можем ждать в городах, например,
если мы приехали во время $10$ и поезд уходит в момент времени $16$, то мы можем подождать до $16$ и уехать на поезде. Нас просят найти минимальное время прибытия в город $T$ из 
города $S$.
Как решить задачу? Допустим, мы можем приехать в город в моменты времени: $10, 16, 25, 30, 60$. Но что нам выгоднее? Заметим, что чем раньше мы приедем в город,
тем больше рейсов нам будет доступно. Например, если мы приедем в $30$, то мы пропустим поезд, который ушел в $20$ секунд, но если мы приедем раньше, то у нас больше шансов попасть на этот поезд.
Поэтому нам просто нужно найти минимальный путь из $S$ в $T$, но при этом по ребрам мы ходим немного по-другому. Если мы приедем в город $x$ в момент $d_x$, то 
мы можем только рассматривать такие ребра, у которых $t_i \geq d_x$. Понимаете, как это написать? Здесь оставлю небольшую подсказку:

\subTitleStyle{Пример 5 (файл algo\_train)}

\ExampleFull{Sections/Dijkstra/algo_train.cpp}

\subTitleStyle{Конец примера 5}

\subsection{Подведение итогов}

\begin{enumerate}[label=\Roman*]
    \item Алгоритм Деикстры работает за $O(m \log {n})$
    \item Используем алгоритм на взвешенных графах без циклов отрицательного веса
    \item Не используем алгоритм, когда веса равны $1$, используем \textbf{bfs} вместо этого
    \item Практикуемся в алгоритме Деикстры
\end{enumerate}

\end{document}
